## 1.1 Создание репозитория

_Задание._
Командная строка терминала находится в каталоге octobox. Необходима инициализация Git репозитория.

_Решение._
В командной строке пишем:
```
git init
```

_Пояснение._
Команда `git init` создаёт репозиторий в текущем каталоге, который позволяет контролировать изменения файлов.

## 1.2 Проверка статуса

_Задание._
Только что мы создали в каталоге octobox пустой репозиторий /.git/. Репозиторий представляет собой скрытый каталог, в котором работает Git. Необходимо просмотреть текущее состояние проекта.

_Решение._
Воспользуемся командой:
```
git status
```

_Пояснение._ 
Команда `git status` показывает нам, в какой ветке мы находимся (по умолчанию это master), какие изменения были внесенны с момента последнего коммита, что ожидает закоммичивания.

## 1.3 Проверка статуса после добавления файла

_Задание._
В репозитории octobox был создан файл octocat.txt. Следует снова проверить статус проекта.

_Решение._
см. решение 1.2 

_Пояснение._
Теперь Git сообщает нам, что файл octocat.txt "untracked". Git воспринимает этот файл, как новый. Это хорошоя практика, часто проверять статус проекта. Иначе можно не заметить некоторых изменений.

## 1.4 Добавление изменения

_Задание._
Сообщить Git о том, что нужно следить за изменениями в файле octocat.txt. Для этого файл необходимо поместить в накопитель изменений.

_Решение._
В этот раз нам поможет команда `git add file_name`
```
git add octocat.txt
```

_Пояснение._
Когда в репозиторий добавляется новый файл, он приобретает статус untracked. Это означает, что Git ещё с ним не знаком. Их нужно познакомить, используя команду `git add file_name`. Это поможет Git отслеживать изменения файла и приготовить его к коммиту. Так же можно воспользоваться командой `git add .`, которая позволит добавить к отслеживанию все файлы текущей дериктории. А если нужно удалить файл из зоны отслеживания, используют команду `git reset file_name`.

## 1.5 Проверка изменения

_Задание._
Git теперь отслеживает файл octocat.txt. Рекомендуется снова проверить статус проекта.

_Решение._
```
git status
```

_Пояснение._
Git сообщил нам, что "changes to be committed". Это означает, что изменения теперь можно коммитить. Прежде чем коммитить мы можем сделать несколько изменений. Все они отразятся в статусе в так называемом Staging Area. Это место, где файлы группируются, чтобы попасть в один коммит. Если файлы с изменениями не подготовленны к коммиту, то им присваивается статус unstaged.

## 1.6 Фиксация изменения (Committing)

_Задание._
Наш файл ещё не в репозитории. До того, как поместить его в репозиторий мы можем ещё что-нибудь добавить или удалить. Когда все необходимые изменения будут внесены, можно их зафиксировать.

_Решение._
Для фиксации изменений пользуемся командой `git commit -m "Сообщение о том, что делает коммит"`. В нашем случае она выглядит так:
```
git commit -m "Add cute octocat story"
```

_Пояснение._
"Commit" представляет собой копию нашего репозитория. И если когда-нибудь нужно будет просмотреть изменения, которые сделали мы (или кто-то другой), нам легко будет восстановить хронологию.

## 1.7 Добавление всех изменений

_Задание._
Мы также можем использовать wildcard, если хотим добавить несколько файлов одинакового типа. В директорию была добавленна группа .txt файлов. Необходимо все эти файлы сделать отслеживаемыми одной командой.

_Решение._
К уже известной команде `git add` вместо имени файла добавляем его расширение в формате `git add '*.расширение'`. Следовательно:
```
git add '*.txt'
```

_Пояснение._
Использование данной команды весьма удобно, когда нужно добавить несколько файлов с одинаковым расширением. Но нельзя забывать про кавычки, иначе Git не будет иметь возможности добавлять файлы в дерикторию.

## 1.8 Фиксация всех изменений

_Задание._
Мы добавили все текстовые файлы в staging area. Теперь можно проверить статус, а затем всё закоммитить.

_Решение._
```
git commit -m "Add all the octocat txt files"
```  

_Пояснение._
Делая фиксацию нескольких файлов нужно быть очень внимательным. Не следует пренебрегать командой `git status`, чтобы убедиться, что все необходимые файлы и папки внесены в staging area.

## 1.9 История

_Задание._
Мы сделали несколько коммитов. Не плохо было бы просмотреть, что мы изменили.

_Решение._
Чтобы Git предоставил нам отчёт об изменениях, воспользуемся командой:
```
git log
```

_Пояснение._
Команда `git log` позволяет нам просмотреть все совершённые ранее изменения в хронологическом порядке. Более подробную информацию о каждом коммите мы можем узнать, воспользовавшись командой `git log --summary`. С её помощью мы можем увидеть, где файл был добавлен впервые, какие файлы были удалены. Это даст хорошее представление о том, что происходило с проектом с момента его создания.

## 1.10 Удалённые репозитории

_Задание._
На сайте GitHub был создан новый пустой репозиторий (https://github.com/try-git/try_git.git). Чтобы поместить наш локальный репозиторий на сервер GitHub мы должны добавить удаленный репозиторий.

_Решение._
Для добавления удалённого репозитория существует команда  `git remote add`, которая включает в себя remote name (удалённое имя) и repository URL (URL репозитория). В нашем случае это:
```
git remote add origin https://github.com/try-git/try_git.git
```
где remote name = origin, а repository URL = https://github.com/try-git/try_git.git.

_Пояснение._
Remote не обязательно должен называться origin, но чаще всего это именно так.
Хорошая идея - поместить свой проект на удалённый сервер (GitHub, например), так можно не переживать, что труд будет безвозвратно утерян при каком-нибудь несчастном случае с компьютером.

## 1.11 Помещение в удалённый репозиторий (Pushing Remotely)

_Задание._
Поместить локальные изменения в репозиторий origin на GitHub.

_Решение._
Команда `push` сообщает Git куда поместить готовые коммиты. Для этого нужно определить remote name (в данном случае это origin) и branch (по умолчанию master). 
```
git push -u origin master
```
Чтобы каждый раз не вводить эти данные, пользуемся `-u`. Данная команда сообщит Git, что нужно запомнить указанные параметры, и в дальнейшем достаточно будет написать `git push`. 

_Пояснение._
Изменения, сделанные локально теперь есть и в GitHub. Это очень удобно для работы в команде.

## 1.12 Извлечение из удалённого репозитория (Pulling Remotely)

_Задание._
Представим, что мы привлекли других людей в наш проект. Они извлекали из GitHub наши файлы, вносили в них измнния, а затем помещали на сервер. Мы можем проверить какие изменения были внесены и добавить новые. Для этого нужно сделать удалённый репозиторий локальным.

_Решение._
Извлечение происходит при помощи команды `pull`. Не стоит забывать про remote name и branch. Их значения не изменились:
```
git pull origin master
```

_Пояснение._
Иногда, перед извлечением бывают созданны итзменения, которые ещё не хочется фиксировать. В таком случае вместо команды `git commit` можно использовать `git stash`, которая прячет изменения, или `git stash apply`, которая повторно применяет изменения после извлечения.

## 1.13 Сравнения

_Задание._
В семье octocat было кое-что добавлено и изменено. Что именно?

_Решение._
Чтобы сравнить 2 каких-либо версии, используем команду `git diff сравниваемые версии`. Так как сравниваемым является самый последний commit, устанавливаем значение HEAD:
```
git diff HEAD
```

_Пояснение._
HEAD указатель, который держит свою позицию во всех коммитах. По умолчанию HEAD в самом последнем коммите, поэтому команду можно использовать в качестве быстрого пути к ссылке.

## 1.14 Различия в накопителе изменений (Staged Differences)

_Задание._
Команду `git diff` так же хорошо использовать для наблюдения за изменениями в файлах, которые уже были в накопителе изменений. В папку octofamily только что добавили файл octodog.txt. Следует поместить его в накопитель изменений.

_Решение._
Пользуемся уже знакомой командой:
```
git add octofamily/octodog.txt
```

_Пояснение._
Теперь наш Файл добавлен в накопитель изменений, о чём нам может сообщить команда `git diff`.

## 1.15 Различия в накопителе изменений (Staged Differences). Продолжение.

_Задание._
Снова проверим различия.

_Решение._
Воспользуемся опцией --staged, чтобы узнать, какие изменения были только что сделаны:
```
git diff --staged
```

_Пояснение._
Иногда хочется сохранить связанные изменения вместе в различных коммитах. Используя `git diff` можно получит хороший обзор внесённых изменений и позволяет добавлять файлы и каталоги по одному за раз и коммитить их по отдельности.

## 1.16 Сброс накопителя изменений

_Задание._
Теперь octodog часть семьи, а octocat в депрессии. Так как мы любим octocat больше, чем octodog, нам следует удалить octodog.txt.

_Решение._
Для удаления ненужного файла существует команда `git reset путь`. Мы хотим удалить файл с путём octofamily/octodog.txt:
```
git reset octofamily/octodog.txt
```

_Пояснение._
Файл octodog.txt всё ещё остался в папке octofamily. Команда `git reset` всего лишь удалила его из накопителя изменений.

## 1.17 Отмена

_Задание._
Было бы здорово, если бы мы могли вернуться к тому, что было до появления octodog. Следует избавиться от всех изменений с момента последнего коммита для octocat.txt.

_Решение._
Изменение файлов можно отменить до того момента, когда был совершён последний коммит:
```
git checkout -- octocat.txt
```

_Пояснение._
Команда `git checkout` переключает Git с одной ветки на другую. Она работает и без "--", но в данном случае командной строке сообщается, что после "--" нет больше опций. Таким образом, если имеется ветвь с именем octocat.txt, Git всё ещё будет возвращать файл, вместо переключения файла на ветку с похожим именем.

## 1.18 Ветвление
 
_Зодание._
Когда разработчики работают над характеристиками или ошибками, они часто создают копии (aka. branch) кода, где можно делать обособленные коммиты. Затем новые ветви можно объединять с главной ветвью master.
Хотелось бы удалить всех этих надоедливых octocats. Для этого можно создать ветку clean_up.

_Решение._
Создавать ветвление довольно просто. Нужно дать Git команду `branch` с требуемым именем ветки:
```
git branch clean_up
```

_Пояснение._
Ветвление часто используется, когда хочется работать над несколькими функциями одновременно. Не хотелось бы, чтобы в конечном итоге ветвь master имела половину Функций А и половину Функций Б. Лучше разделить базовый код на 2 одинаковые части и работать с ними по отдельности. Как только одна из частей будет готова, их можно будет соединить в ветвь master и отправить на удалённый репозиторий.

## 1.19 Переключение между ветвями

_Задание._
Теперь, если мы напишем команду `git branch`, мы увидим 2 локальные ветви: главную, с именем master и нашу новую ветвь clean_up. По умолчанию мы на главной, давайте переключимся.

_Решение._
Даём Git команду `checkout` с именем ветви, на которую следует переключиться:
``` 
git checkout clean_up
```

_Пояснение._
Используя команду `git checkout имя_ветви`, мы переключаемся между различными ветвями. Нам также известна команда для создания новой ветки: `git branch имя_новой_ветки`. Кроме того, мы можем, используя одну команду, добавить новую ветвь и одновременно переключиться на неё. Эта команда включает в себя две предыдущие: `git checkout -b имя_новой_ветки`.

## 1.20 Удаление всех octocats

_Задание._
Мы переместились на ветку clean_up. Теперь мы можем удалить всех этих надоедливых octocats. 

_Решение._
Для удаления файла не только из накопителя изменений, но и с диска воспользуемся командой `git rm`. А чтобы не удалять файлы по одному, добавим свойство '*.txt':
```
git rm '*.txt'
```

_Пояснение._
Возможность удаления одного или всех файлов весьма полезна. Но иногда нужно удалить всю папку целиком. В этом случае можно использовать рекурсивную опцию на `git rm` - `git rm -r folder_of_cats`. Это рекурсивно удалит все папки и файлы из данного каталага.

## 1.21 Фиксация изменения ветви

_Задание._
После того, как мы удалили все octocats, нам нужно это закоммитить.

_Решение._
```
git commit -m "Remove all the cats"
```

_Пояснение._
Если случалось удалить файл без использования `git rm`, обнаруживалось, что `git rm` всё равно придётся использовать для удаленные файлов из рабочего дерева. Можно сохранить этот шаг с помощью опции "-а" в `git commit`, которая автоматически удаляет удаленные файлы с коммитами (к примеру, `git commit -a -m "Delete stuff"`)

## 1.22 Переключение назад в master

_Задание._
Итак, мы почти закончили с котами. Теперь нужно просто вернуться к главной ветви и копировать (или объединить) изменения с ветки clean_up назад, в master.

_Решение._
Переключимся на ветку master:
```
git checkout master
```

_Пояснение._
Сейчас у нас есть 2 ветки. Мы можем свободно переключаться между ними, вносить изменения в одну и ту же папку для сравнения двух вариантов. Когда окончательный вариант будет найден, нужно будет просто объединить ветки.

## 1.23 Подготовка к объединению

_Задание._
Итак, настал момент, когда нужно объединить изменённую ветку clean_up с веткой master.

_Решение._
Поможет нам в этом команда `git merge` с указателем имени сливаемой ветки:
```
git merge clean_up
```

_Пояснение._
Если одновременно вносить изменения в один и тот же файл в различных ветвях, то могут происходить так называемые Merge Conflicts. Не стоит этого бояться. Нужно просто определиться, какой код сохранить.

## 1.24 Сохранение чистоты

_Задание._
Мы устранили ошибки и сделали слияние ветвей. Теперь нужно убрать за собой.

_Решение._
Так как мы создавали только одну дополнительную ветку (clean_up), нужно удалить только её. Мы можем использовать команду `git branch -d имя_ветки` для удаление уже не нужного нам отростка:
```
git branch -d clean_up
```

_Пояснение._
Команда `git branch -d имя_ветки` работает только в случае, когда произошло объединение ветвей. Если хочется удалить ненужную ветвь без объединения, можно добавить любую из двух опций: опцию --force (-f), или использовать -D в сочетании с комбинацией -d -f в одной команде.

## 1.25 Финальное помещение в удалённый репозиторий

_Задание._
Остался последний шаг - поместить всё на удалённый репозиторий.

_Решение._
Мы уже определили что и куда поместить, а также сообщили Git, что  эти данные нужно запомнить. Так что теперь достаточно написать:
```
git push
```

_Пояснение._
Мы поверхностно прошли курс по Git. Чтобы узнать все возможные функции Git можно просмотреть [документацию](http://git-scm.com/docs). [Pro Git book](http://git-scm.com/book) Скотта Чакона - отличный ресурс, обучающий внутренней работе Git. [help.github](https://help.github.com/) и другие треннинги GitHub также отлично подходят при использовании Git в целом и GitHub в частности.

