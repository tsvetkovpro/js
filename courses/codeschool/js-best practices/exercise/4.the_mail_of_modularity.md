# 4.1 Основы пространства имён

## 4.2 Группировка и защита

_Задание._
Как называется объект, который группирует и защищает соответствующие данные и методы?

_Решение._
Такой объект называется `Namespace`.

_Пояснение._
Namespace (пространство имён) — некоторое множество, под которым подразумевается модель, абстрактное хранилище или окружение, созданное для логической группировки уникальных идентификаторов (то есть имён). 

## 4.3 Доказательство своей значимости

_Задание._
"Загадки, загадки; не очень весело. Докажи свою ценность, Dhuun, конец близок."  
Приложение, которое имеет несколько файлов, содержащих переменные с одинаковыми именами, будет испытывать потерю данных в случае 1.__________, которая стирает старые данные в пользу новых (и, возможно, неправильных). Это происходит именно тогда, когда эти переменные объявлены 2.__________ в нескольких файлах. Эта ошибка не может быть обнаружена до 3.__________. 

_Решение._
Приложение, которое имеет несколько файлов, содержащих переменные с одинаковыми именами, будет испытывать потерю данных в случае перезаписи (overwrite), которая стирает старые данные в пользу новых (и, возможно, неправильных). Это происходит именно тогда, когда эти переменные объявлены глобально (globally) в нескольких файлах. Эта ошибка не может быть обнаружена до выполнения программы (run-time). 

_Пояснение._
Приоритет будет иметь тот файл, который добавлен ниже в HTML. Такую ошибку не легко обнаружить сразу, но она может кординально изменить конечный результат.

## 4.4 Вход в пещеры

_Задание._
"Смотри," - говорит Aiedra, - "это файл cavesofclarity.js! Данные внутри него в настоящее время глобальны и уязвимы для зла. Преобразуй этот файл так, чтобы он содержал в себе только один объект, который защитит данные."
```javascript
var stalactites = 4235;
var stalagmites = 3924;
var bats = 345;
var treasureChests = 3;
var openChest = function () {
    treasureChests--;
    alert("DA DADADA DAAAAAAA!");
};
```

_Решение._
Создадим в файле глобальный объект CAVESOFCLARITY, а все переменные сделаем его свойствами; не забудем в функции применить this:
```javascript
var CAVESOFCLARITY = {
    stalactites: 4235,
    stalagmites: 3924,
    bats: 345,
    treasureChests: 3,
    openChest: function () {
        this.treasureChests--;
        alert("DA DADADA DAAAAAAA!");
    }
};
```

_Пояснение._
Теперь глобальные переменные стали локальными свойствами одного Namespace обекта. Его отличие от остальных объектов в том, что он идентифицируется заглавными буквами.

## 4.5 Доступ предоставляется

_Задание._
"HTML страница для Caves of Clarity сейчас скрывается в темноте," - заметила Aiedra. - "Она потеряла доступ к данным, которые когда-то были глобальными. Освети своим факелом эту одинокую линию, обеспеч открытие сундука и слушай музыку."
```html 
<!DOCTYPE>
<html>
    <body>
        <h1>Level 4 Caves of Clarity</h1>
        <script type="text/javascript" src="cavesofclarity.js"></script>
        <button onclick="openChest();"> Open the Secret Treasure!</button>
    </body>
</html>
```

_Решение._
Перед вызовом функции добавим имя объекта:
```html
<button onclick="CAVESOFCLARITY.openChest();"> Open the Secret Treasure! </button>
```

_Пояснение._
Теперь, чтобы получить доступ к требуемым данным, будем вызывать свойства объекта.

## 4.6 Защита или пиратство?

_Задание._
Проходя ещё глубже в пещеру, я столкнулась с одноногим человеком. Сидя лицом к грубой стене, он покосился на меня исподлобья утверждая: "Namespace гарантирует полную защиту данных."   
Так ли это?

_Решение._
`False`, Namespace не гарантирует полную защиту данных.

_Пояснение._
Namespace не может полностью защитить данные. Так, к примеру кто-то может задать Namespace с тем же идентификатором. Но проверить имя одного объекта гораздо проще, чем всего содержимого документа.

## 4.7 Сундук с сокровищами

_Задание._
Пещерам нужна немного лучшая защита для их treasureChests. Используя свои знания о "вложениях",  я должна построить новый контейнер внутри существующего. Для этого нужно добавить переменную treasureChests и метод, который сопровождает открытие сундука. Можно назвать этот контейнер SECRET.

_Решение._
Внутри объекта CAVESOFCLARITY создадим свойство SECRET в качестве объекта со свойством treasureChests и методом openChest:
```javascript
var CAVESOFCLARITY = {
    stalactites: 4235,
    stalagmites: 3924,
    bats: 345,
    SECRET: {
        treasureChests: 3,
        openChest: function () {
            this.treasureChests--;
            alert("DA DADADA DAAAAAAA!");
        }
    }
};
```

_Пояснение._
Помещая один объект Namespace в другой, можно обеспечить большую защиту. Второе пространство имени оформляется так же, как обычное свойство, только именуется всеми заглавными буквами.

## 4.8 Секреты

_Задание._
"Увы, HTML страница снова погрузилась во тьму," - обратила внимание Aiedra. - "Верни освещение, перемодифицировав вызов функции для размещённого тобой нового вложения."

_Решение._
Теперь openChest является методом SECRET, поэтому доступ к нему немного изменился:
```html
<!DOCTYPE>
<html>
  <body>
    <h1>Level 4 Caves of Clarity</h1>
    <script type="text/javascript" src="cavesofclarity.js"></script>
    <button onclick="CAVESOFCLARITY.SECRET.openChest();"> Open the Secret Treasure! </button>
  </body>
</html>
```

_Пояснение._
См. [4.2-4.7](https://github.com/Preigile/CodeschoolHints/blob/master/JavaScript/JavaScript_Best_Practices/4.the_mail_of_modularity.md#42-%D0%93%D1%80%D1%83%D0%BF%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0-%D0%B8-%D0%B7%D0%B0%D1%89%D0%B8%D1%82%D0%B0).

## 4.9 Неосведомлённый

_Задание._
Aiedra снисходительно улыбается: "Ты преуспела в доведении Namespace в пещеры. Ещё один вопрос, прежде чем мы отправимся дальше вниз, в темноту..."  
Она проплывает мимо меня, перед твёрдой каменной стеной: "Этот путь закрыт, но остался один пароль. Возможно, ты помнишь, что, если другой файл с другим пространством имени понадобится HTML файлу Caves, то два файла не должны знать друг о друге, если это не запланированно. Это полезное блокирование информации помогает тебе в защите данных... какой термин существует для такого незнания, Dhuun?"

_Решение._
Независимость файлов называется `agnostic`.

_Пояснение._
Файлы agnostic работают вместе только при условии, что у каждого своё пространство имён.

# 4.10 Анонимное замыкание

## 4.11 Немного того, немного этого

_Задание._
Какая функция используется для вызова нескольких приватных параметров, связанных только с окружающей функцией и нескольких публичных свойств, доступных для всех держателей namespace?

_Решение._
Такой функцией является `anonymous closures`.

_Пояснение._
Иногда хочется оставить некоторые свойства приватными, а некоторые оставить доступными. В таких случаях можно использовать анонимное замыкание (anonymous closures).

## 4.12 Приватный против публичного

_Задание._
Другая массивная стена появилась после длинного пути. На её поверхности выводятся ломаные фразы в светящемся скрипте. Aiedra шепчет, как бы про себя: "Знания дадут ключ. Покажи своё понимание сложных модулей. Подумай хорошенико... найди правильные слова."   
__________ свойства __________ в локальной области видимости __________.   
__________ свойства построены в __________, который затем __________, чтобы стать __________.   
Доступ к __________ данным, таким образом, возможен только потому, что __________ внутри самого большого __________.      
Размышляя над ответом, я отодвинула мысль, что она была здесь раньше.

_Решение._
Приватные (private) свойства созданны (created) в локальной области видимости функционального выражения (function expression).   
Пибличные (public) свойства построены в объекте (object), который затем возвращается (returned), чтобы стать пространством имён (namespace).   
Доступ к приватным (private) данным, таким образом, возможен только потому, что закрыт (closure) внутри самого большого модуля (module).   

_Пояснение._
В анонимном замыкании приватные свойства создаются в локальной области видимости, а публичные возвращаются в виде объекта.

## 4.13 Построение приватных данных

_Задание._
"Вместо использования только вложенного namespace," - заметила Aiedra, - "Давай создадим модуль CAVESOFCLARITY, где количество ящиков с сокровищами сделаем приватным через анонимное замыкание."    
Она подняла взгляд на потолок пещеры: "Сейчас мы позволим геологическим созданиям и возможностям таким, как метод для открытия ящиков, остаться публичными, доступными через пространство имён."   
Указывая на файл cavesofclarity.js, она обозначает место для моих осторожных изменений: "Ты должна использовать свои знания создания публичных и приватных свойств в модуле, чтобы вновь тщательно организовать данные. Так ты увеличишь безопасность пещер."   
1) Для начала сделать treasureChests приватным, преобразовав CAVESOFCLARITY в анонимное замыкание, которое возвращает объект с оригинальными данными;   
2) Затем для CAVESOFCLARITY инициализированном как результат замыкания, сделать непосредственный вызов замыкания;   
3) В конце концов, сделать свойство treasureChests приватным путём локального объявления переменной внутри замыкания.

_Решение._
Создадим анонимное замыкание и его вызов. В return поместим объект, содержащий в себе те же свойства, что и CAVESOFCLARITY. Из объекта SECRET вынесем свойство treasureChests, сделав его локальной переменной. А в методе openChest удалим this, так как treasureChests больше не свойство:
```javascript
var CAVESOFCLARITY = (function () {
    var treasureChests = 3;
    return {stalactites: 4235,
        stalagmites: 3924,
        bats: 345,
        SECRET: {
            openChest: function () {
                treasureChests--;
                alert("DA DADADA DAAAAAAA!");
            }
        }
    };
})();
```

_Пояснение._
Структура анонимного замыкания:
```javascript
var ИМЕННОЕПРОСТРАНСТВО = (function () {
    var скрытыеСвойства = "значение";
    return {
        отображаемыеСвойства: "значение"
    };
})();
```

## 4.14 Публичное под влиянием приватного

_Задание._
На какой оператор, при выполнении, окажет влияние приватное свойство?

_Решение._
Приватное свойство окажет влияние на `treasureChests--;`.

_Пояснение._
Приватное свойство не видимо для пользователя, но с ним можно производить различные действия внутри публичного.

## 4.15 Безопасность летучих мышей

_Задание._
Aiedra услышала что-то вдалеке. После короткого молчания она сказала: "Пещеры пропели мне тихо. Они хотят защитить своих существ. Модифицируй модуль, сделав данные bats приватными."

_Решение._
Сделаем свойство bats локальной переменной:
```javascript
var CAVESOFCLARITY = function () {

    var treasureChests = 3;
    var bats = 345;

    return {
        stalactites: 4235,
        stalagmites: 3924,
        SECRET: {
            openChest: function () {
                treasureChests--;
                alert("DA DADADA DAAAAAAA!");
            }
        }
    };
}();
```

_Пояснение._
См. [4.12-4.14](https://github.com/Preigile/CodeschoolHints/blob/master/JavaScript/JavaScript_Best_Practices/4.the_mail_of_modularity.md#412-%D0%9F%D1%80%D0%B8%D0%B2%D0%B0%D1%82%D0%BD%D1%8B%D0%B9-%D0%BF%D1%80%D0%BE%D1%82%D0%B8%D0%B2-%D0%BF%D1%83%D0%B1%D0%BB%D0%B8%D1%87%D0%BD%D0%BE%D0%B3%D0%BE).

## 4.16 Бесполезное замыкание

_Задание._
"Несмотря на то, что ты эффективно сделала количество bats приватным, мне интересно, сможешь ли ты увидеть проблему, которая за этим последовала?" - Aiedra терпеливо ждёт моего анализа. Что произошло?

_Решение._
Поскольку на bats никогда не ссылаются через публичные методы, его данные не несут в себе никакой функциональной нагрузки.

_Пояснение._
См. Решение.

## 4.17 Летучие мыши на все времена

_Задание._
"Чтобы гарантировать, что на количество летучих мышей будет ссылка, построй публичный метод getBats, который вернёт это приватное свойство. Из твоей хорошей работы сумма мышей бедет извлекаема, но количество останется на века."   
1) Для начала, нужно создать функцию getBats в возвращаемом объекте замыкания;   
2) Показать значение bats внешнему миру.

_Решение._
В возвращаемом объекте создадим метод getBats, который вернёт bats:
```javascript
var CAVESOFCLARITY = function () {

    var treasureChests = 3;
    var bats = 345;

    return {
        stalactites: 4235,
        stalagmites: 3924,
        SECRET: {
            openChest: function () {
                treasureChests--;
                alert("DA DADADA DAAAAAAA!");
            }
        },
        getBats: function () {
            return bats;
        }
    };
}();
```

_Пояснение._
Доступ к публичным объектам подобен доступу к [свойствам Namespace](https://github.com/Preigile/CodeschoolHints/blob/master/JavaScript/JavaScript_Best_Practices/4.the_mail_of_modularity.md#45-%D0%94%D0%BE%D1%81%D1%82%D1%83%D0%BF-%D0%BF%D1%80%D0%B5%D0%B4%D0%BE%D1%81%D1%82%D0%B0%D0%B2%D0%BB%D1%8F%D0%B5%D1%82%D1%81%D1%8F): нужно обозначить именное пространство, а затем идентификатор свойства (к примеру, CAVESOFCLARITY.getBats).

## 4.18 IIFE

_Задание._
"Ты хорошо справлялась до сих пор," - сказала Aiedra, когда мы приблизились к подземному озеру. Вода успокаивает и мерцает, как стекло, от света моего факела.   
"Ответ на финальный вопрос призовёт лодку, которая переправит тебя на другой берег," - она проплывает над водой, оставляя меня на берегу в темноте. - "Что даст возможность переменной CAVESOFCLARITY, непосредственно содержать объект, который служит в качестве модуля, а не функции?"

_Решение._
Скобки, которые непосредственно запускают функцию.

_Пояснение._
Нельзя забывать ставить круглые скобки вызова анонимной функции сразу после её определения, иначе все усилия будут напрасны.

# 4.19 Глобальный импорт

## 4.20 Глобальный захват

_Задание._
Aiedra обнаружила тусклый свет в далеке: "Если модуль ссылается на глобальные переменные, лучше всего переносить их в область видимость анонимного замыкания посредством использования специальной техники. Как она называется?"

_Решение._
Такая техника называется глобальным импортом (global imports).

_Пояснение._
Конечно, лучше всего объявлять локальные переменные, но иногда это не представляется возможным. В таком случае хорошей практикой считается использование глобального импорта.

## 4.21 Построение импорта

_Задание._
"Заверь часть файла для LexicalLake," - говорит Aiedra. - "Внутри ты найдёшь использование глобальной переменной explorerAnswer, которая нигде в файле больше не появляется... возможно она принадлежит cavesofclarity.js... возможно explorerentries.js... кто знает? В любом случае, каждый раз её использования проверяется вся цепочка области видимости и разработчики не сразу понимают, что она носит глобальный характер."   
Aiedra на мгновенье замолчала, прислушиваясь к водоворотам и всплескам озера, скольжению лодки: "Озеро просит тебя о помощи в достижении лучшей производительности. Используй свои знания глобального употребления в моделях, обеспечь ей импорт," - Aiedra проскользила в глубокую тьму. - "Используй answer в качестве нового параметра."
```javascript
var LexicalLake = function () {

    var depth = 400;
    var fish = 1200;
    var unknownSleepers = 3;

    return {
        getFish: function () {
            return fish;
        },
        getDepth: function () {
            return depth;
        },
        getSleepers: function () {
            return unknownSleepers;
        },
        awakenSleeper: function () {
            alert("Far below, in the deep, something awakens. Row faster.");
        },
        summonBoat: function () {
            if (explorerAnswer === "agnostic") {
                alert("The boat fades into view.");
            }
            else {
                alert("...the lake is silent.");
            }
        }
    };
}();
```

_Решение._
Передаём в анонимное замыкание в качестве параметра переменную answer, которой, затем, заменим explorerAnswer в условии, которую передадим в вызов:
```javascript
var LexicalLake = function (answer) {

    var depth = 400;
    var fish = 1200;
    var unknownSleepers = 3;

    return {
        getFish: function () {
            return fish;
        },
        getDepth: function () {
            return depth;
        },
        getSleepers: function () {
            return unknownSleepers;
        },
        awakenSleeper: function () {
            alert("Far below, in the deep, something awakens. Row faster.");
        },
        summonBoat: function () {
            if (answer === "agnostic") {
                alert("The boat fades into view.");
            }
            else {
                alert("...the lake is silent.");
            }
        }
    };
}(explorerAnswer);
```

_Пояснение._
Суть глобального импорта состоит в том, что требуемая используется только во время вызова функции, а в самой функции вместо неё используется переданная в качестве параметра локальная переменная.

## 4.22 Процесс импортирования

_Задание._
После добавления глобального импортирования для модуля озера, вода вспенилась вокруг лодки. Рябь и волны стали переменчивыми и окружили каскадной стеной медленно поднимающихся тёмных вод нашу лодку. Сквозь туман я увидела ломанные фразы, оставленные в воде. Голос Aiedra раздался сквозь шум падающей жидкости: "Озеро призывает тебя разобраться с закрытым сейчас Mail of Modularity. Заверши фразы, чтобы добраться до другого берега."   
Ваш ______ обеспечивает чёткость ______ внутри ______.
Используя ______, вы защищаете ______ данные, которые могли бы оказаться ______.   
Все импортированные данные становятся ______ областью видимости для ______, которая будет использоваться в ______.   
Таким образом, по сравнению с ______ всей ______, ______ будут чище и быстрее.   

_Решение._
Ваш импорт (import) обеспечивает чёткость области видимости (scope) внутри модуля (module).
Используя параметр (parameter), вы защищаете глобальные (global) данные, которые могли бы оказаться перезаписанны (overwritten).   
Все импортированные данные становятся локальной (locally) областью видимости для анонимной функции (anonymous function), которая будет использоваться в замыкании (closure).   
Таким образом, по сравнению с поиском (searching) всей цепочки областей видимости (scope chain), импортирования (imports) будут чище и быстрее.

_Пояснение._
Проблема глобальных переменных заключается не только в том, что они снижают производительность, но и в том, что они могут запутать не знающего разработчика, кто-нибудь может изменить их значение и тогда код будет работать не так, как ожидалось.

## 4.23 Спящая комета

_Задание._
Вода спадает и, вскоре, её поверхность становится смертельно тихой. Забвение опускается на огромную пещеру как толоко я достигаю противоположного берега. Aiedra останавливается и смотрит на озеро. Её взгляд устремлён в глубь и, кажется, она увидела нечто. Впервые она испуганно вздрагивает: "Быстрее, исследователь, ты должна добавить функцию для публичных свойств в модуль Озера. Назови её stopSleeper. Тебе нужно будет импортировать вторую переменную и установить новый параметр... названный foundShore. Это глобальная переменная, которая берёт своё значение из madeItAcross. Если foundShore истинно, твоя функция должна вывести заклинание "That which has awoken shall now return to slumber.", а если нет, т сообщение "A Sleeper cometh. Abandon hope."."   
Вода начнает медленно подниматься пузырьками.    
"Сейчас, Dhuun! Не останавливайся! Даже я не могу остановить это!"
```javascript
var LEXICALLAKE = function (answer) {

    var depth = 400;
    var fish = 1200;
    var unknownSleepers = 3;

    return {
        getFish: function () {
            return fish;
        },
        getDepth: function () {
            return depth;
        },
        getSleepers: function () {
            return unknownSleepers;
        },
        awakenSleeper: function () {
            alert("Far below, in the deep, something awakens. Row faster.");
        },
        summonBoat: function () {
            if (answer === "agnostic") {
                alert("The boat fades into view.");
            }
            else {
                alert("...the lake is silent.");
            }
        },


    };
}(explorerAnswer);
```
1) Во-первых, нужно передать глобальную переменную madeItAcross и взять её в качестве параметра замыкания foundShore;   
2) Далее, создать метод stopSleeper;   
3) Затем, вывести соответствующие сообщения: когда foundShore истинно - "That which has awoken shall now return to slumber.", а когда ложно - "A Sleeper cometh. Abandon hope."

_Решение._
Передадим в функцию и в её вызов ещё по одному параметру и создадим метод stopSleeper с выводом сообщений соответственно условиям:
```javascript
var LEXICALLAKE = function (answer, foundShore) {

    var depth = 400;
    var fish = 1200;
    var unknownSleepers = 3;

    return {
        getFish: function () {
            return fish;
        },
        getDepth: function () {
            return depth;
        },
        getSleepers: function () {
            return unknownSleepers;
        },
        awakenSleeper: function () {
            alert("Far below, in the deep, something awakens. Row faster.");
        },
        summonBoat: function () {
            if (answer === "agnostic") {
                alert("The boat fades into view.");
            }
            else {
                alert("...the lake is silent.");
            }
        },
        stopSleeper: function () {
            if (foundShore) {
                alert('That which has awoken shall now return to slumber.');
            } else {
                alert('A Sleeper cometh. Abandon hope.');
            }
        }
    };
}(explorerAnswer, madeItAcross);
```

_Пояснение._
Мы можем передавать в анонимной функции сколько угодно методов для глобальных переменных.

# 4.24 Augmentation

## 4.25 Определение дополнения

_Задание._
Два тёмных коридора, идентичные и внушительные, очертания впереди, на плоской стене. Правильное направление не указано и ни одно не подсказанное Aiedra, терпеливо парящей рядом, не кажется истинным: "Ты знаешь термин для добавления или изменения свойств в модуле после его построения?"

_Решение._
Этот термин - `augmentation`.

_Пояснение._
После того, как модуль построен в одном файле, к нему можно добавлять новые и изменять в нём старые, но уже в другом файле.

## 4.26 Построение модуля

_Задание._
Как только я произнесла правильный ответ, один из коридоров полностью исчез. Остался только один в ход на поверхности стены, словно второго никогда и не существовало.    
"К счастью, ты избежала потери в Caves of Clarity навсегда," - заметила Aiedra. - "И не смотря на то, что нет пути назад, ты открыла путь вперёд."   
Я шагнула в коридор и подняла факел. Почти тотчас же передо мной появился длинный бассейн горячей, жидкой магмы.   
"Прежде, чем Caves of Clarity преподнесёт тебе этот подарок, ты должна дать ему свой," - Aiedra указывает на магму. - "Для устранения этого барьера тебе необходимо увеличить модуль CAVESOFCLARITY с одной частью приватных данных и одним публичным свойством, которое извлекает её. Серия задач завершит твои модификации."   
cavesofclarity.js:
```javascript
var CAVESOFCLARITY = function () {

    var treasureChests = 3;
    var bats = 345;

    return {
        stalactites: 4235,
        stalagmites: 3924,
        SECRET: {
            openChest: function () {
                treasureChests--;
                alert("DA DADADA DAAAAAAA!");
            }
        }
    };
}();
```
1) В новом файле для дополнния sandscript.js построить namespace и присвоить ему пустое функциональное выражение, которое непосредственно запускается;   
2) Далее, обеспечить функциональное выражение старым объектом модуля. Назвать этот параметр caves;   
3) Создать новое приватное свойство sandScript и присвоить ему пустую строку "";   
4) Создать новый публичный метод setSandScript в модуле. Он должен принимать строковый параметр message и присваивать его в качестве приватного свойства значения sandScript;   
5) Вернуть новый дополненый назад в пространство имени.

_Решение._
В файле sandscript.js создадим новое пространство имени CAVESOFCLARITY (без ключевого слова var) и присвоим ему анонимное замыкание с параметром caves, который в вызове станет CAVESOFCLARITY. В теле функции создадим переменную sandScript и присвоим её пустую строку. Далее, для старой области видимости создадим метод setSandScript и передадим ему message, присвоив его теперь переменной sandScript. Вернём caves:
```javascript
CAVESOFCLARITY = function (caves) {
    var sandScript = "";
    caves.setSandScript = function (message) {
        sandScript = message;
    };
    return caves;
}(CAVESOFCLARITY);
```

_Пояснение._
Дополняющий модуль подобен созданию [Namespace](https://github.com/Preigile/CodeschoolHints/blob/master/JavaScript/JavaScript_Best_Practices/4.the_mail_of_modularity.md#42-%D0%93%D1%80%D1%83%D0%BF%D0%BF%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0-%D0%B8-%D0%B7%D0%B0%D1%89%D0%B8%D1%82%D0%B0), но для его построения не нужно употребление ключевого слова var, в вызове используется старый Namespace, а для того, чтобы сделать свойства или методы публичными, из [создают](https://github.com/Preigile/CodeschoolHints/blob/master/JavaScript/JavaScript_Road_Trip_Part_3/4.the_ocean_of_objects.md#45-%D0%9F%D0%BE%D1%81%D1%82%D1%80%D0%BE%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-ii) так же, как любое другое свойство или метод вне объекта. Возвращает augmentation старый Namespace.

## 4.27 Частный доступ

_Задание._
Когда я закончила augmenting модуля CAVESOFCLARITY, короткая ограда, квадратная и деревянная, поднялась из каменной земли. Внутри этой ограды простелился толстый ковёр белого песка, подобного песочнице. В непосредственной близости от перил, в полу появилась круглая кнопка. Она пульсирует зелёным цветом.   
Я нажимаю на кнопку и песок начинает перемещаться и формироваться через невидимую силу. Его крупицы сливаются, разделяются и медленно танцуют внутри хорошо знакомого скрипта. Пишущий песок показывает ломанные фразы. В тусклом свете факела, я знаю, что должна сделать.   
В простом ______, файл ______ и augmentation файл ______ делится своими ______.   
______ дополнительного модуля могут быть ______ только как ______ данные из этих ______ файлов.   
______ данные из ______ замыкания ______ теряться и ______ доступны для всех оригинальных ______ которые ссылаются на него.

_Решение._
В простом дополнении (augmentation), файл модуля () и augmentation файл не (do not) делится своими частными состояниями (private state).   
Свойства (properties) дополнительного модуля могут быть доступны (access) только как приватные (private) данные из этих замкнутых (closure) файлов.   
Приватные (Private) данные из оригинального (original) замыкания не будут (will not) теряться и будут (will) доступны для всех оригинальных свойств (properties) которые ссылаются на него.

_Пояснение._
Таким образом можно импортировать различные объекты, расширять, дополнять и изменять их.