# 1.1 Раздел 1 - Функциональные выражения и анонимные функции

## 1.2 Изменение объявления в выражениях

_Задание._
Внутри файла Haunted Hickory House, разработчики из Forest of Function Expressions Theme Park создали объявление функции forestFright. Однако, они решили не хранить функцию в памяти, а использовать её только если свирепые животные проделают свой путь в HHH.    
Изменить функцию на анонимное функциональное выражение и присвоить её переменной runAway.
```javascript
function forestFright() {
    var toAlert = "";
    for (var i = 0; i < 5; i++) {
        toAlert = toAlert + "Lions, Tigers, and Bears, Oh My!!\n";
    }
    alert(toAlert);
}
```

_Решение._
Тут всё довольно просто. Удаляем имя функции, присваиваем её переменной runAway и не забываем в конце поставить точку с запятой:
```javascript
var runAway = function () {
    var toAlert = "";
    for (var i = 0; i < 5; i++) {
        toAlert = toAlert + "Lions, Tigers, and Bears, Oh My!!\n";
    }
    alert(toAlert);
};
``` 

_Пояснение._
Именные функции доступны везде в области видимости. Анонимные же только с момента их объявления. Обычно они используются, когда функцию нужно вызвать только раз. Параметры в таком случае передаются именем переменной, которую JS считает функцией. если же параметры не определены, выводится всё содержимое переменной, вся функция. После объявления переменной ставится точка с запятой, наш случай не исключение.

## 1.3 Использование функциональных выражений с аргументами

_Задание._
Разработчики Death-Defying Dogwoods вычислили специальную формулу для подсчёта Страха в DDD (это важно знать, если вы работаете в тематических парках). Их тайная формула основана на количестве людей в Dogwoods, текущих осадках и, как можно ожидать, количестве акул. Да. Акул.    
Вот их гениальная формула:
```javascript
var fearGenerated = function (numPeeps, rainInInches, numSharks) {
    var rainFear = numPeeps * rainInInches;
    var sharkFear = numSharks * numSharks * numSharks;
    var totalFear = sharkFear + rainFear;
    return totalFear;
};
```
Целью разработчиков является сгенерировать Страх не больше 400, но и не меньше 100 (это не работаете в бизнесе, к сожалению!).    
Они попросили проанализировать формулу, а затем присвоить значения переменным в dogwoods.js, которые должны вызвать выражение функции на следующей строке, с помощью новых значений в качестве параметров, и сохранить результат в переменной fear.

_Решение._
Переменным присваиваем значения так, чтобы генерируемый страх, соответственно готовой формуле, был 100>totalFear>400. На последней строке новой переменной fear присваиваем значение переменной fearGenerated, где в качестве аргументов выступают созданные ранее переменные в соответствующем порядке:
```javascript
var people = 6;
var rain = 11;
var sharks = 5;
var fearGenerated = function (numPeeps, rainInInches, numSharks) {
    var rainFear = numPeeps * rainInInches;
    var sharkFear = numSharks * numSharks * numSharks;
    return sharkFear + rainFear;
};
var fear = fearGenerated(people, rain, sharks);
```

_Пояснение._
Присваивая переменной функцию, нет необходимости в двойном имени (оставляем функцию анонимной). А чтобы выполнить такую функцию, нужно к имени переменной добавить скобки, аргументы и точку с запятой.

## 1.4 Показ содержимого функции

_Задание._
Периодически разработчикам Haunted Hickory House нужно напоминать об их собственной гениальной формуле. Они попросили найти способ, чтобы выводить предупреждение формулы функции на экран, а не просто выполнять функцию. Другими словами, они хотели бы видеть реальное содержимое переменной, которая хранит свои функции. В hauntedHickoryHouse.js, написать строку кода, который обрабатывает их просьбу. Ниже приводится присвоенное выражение функции, для справки:
```javascript
var fearGenerated = function (numPeeps, rainInInches, numSharks) {
    var rainFear = numPeeps * rainInInches;
    var sharkFear = numSharks * numSharks * numSharks;
    var totalFear = sharkFear + rainFear;
    return totalFear;
};
```

_Решение._
Под уже готовым кодом добавим предупреждение, которое выведет на экран всё содержимое переменной fearGenerated:
```javascript
alert(fearGenerated);
```

_Пояснение._
Когда мы используем имя переменной без круглых скобок и аргументов, нам как бы цитируется всё содержимое переменной.

## 1.5 Передача переменных функциональных выражений как параметров

_Задание._
Итак, само собой разумеется, что некоторые люди не захотят испытать the Hickory Haunted House если страх значительно повышен в этот день.       
Разработчики попросили проверить уже созданное значение страха на этот день и решить какой он: НИЗКИЙ, СРЕДНИЙ или ВЫСОКИЙ. В зависимости от тяжести страха, они хотят конкретное подтверждающее сообщение, построенное внутри функционального выражения, которое сохраняется в переменной fearMessage. Затем эта переменная должна просматриваться в функции confirmRide. Кроме того, результаты вызова confirmRide следует хранить в переменной с именем startRide (т.е. истинно, или ложно, от подтверждения пользователя).     
Сообщения подтверждения должны иметь следующие форматы:
  * Для уровней страха менее 200:
```
Fear Level: LOW
Should be no problem at all...mwahaha.
Still wanna ride?
```
  * Для уровней страха от 200 и до 300 включительно:
```
Fear Level: MEDIUM
You may want to rethink this one, man. MWAHAHA!
Think you'll make it?
```
  * Для уровней страха от 300 до 400:
```
Fear Level: HIGH
ABANDON ALL HOPE!!
Have a death wish?
```

_Решение._
Создаём условия, в которых, в зависимости от количества стаха, переменной fearMessage присваиваются различные функциональные выражения, которые, в свою очередь, выводят соответствующие сообщения с возможностью согласиться и отказаться. Кроме того, определяем переменную startRide, присвоив ей уже готовую функцию  confirmRide с аргументом fearMessage:
```javascript
var fear = fearGenerated(numPeeps, rainInInches, numSharks);

var fearMessage;

if (fear < 200) {
    fearMessage = function () {
        return confirm("Fear Level: LOW.\n" +
            "Should be no problem at all...mwahaha.\n" +
            "Still wanna ride?");
    };

} else if (fear <= 300) {
    fearMessage = function () {
        return confirm("Fear Level: MEDIUM.\n" +
            "You may want to rethink this one, man. MWAHAHA!\n" +
            "Think you'll make it?");
    };

} else {
    fearMessage = function () {
        return confirm("Fear Level: HIGH.\n" +
            "ABANDON ALL HOPE!!\n" +
            "Have a death wish?");
    };
}

var startRide = confirmRide(fearMessage);

function confirmRide(confirmToGo) {
    return confirmToGo();
}
```

_Пояснение._
Переменные, которые содержат функцию, могут быть переданы в другие функции. Функциональные выражения могут дать гибкость при выборе какую функцию построить.

# 1.6 Раздел 2 - Передача функционального выражения в качестве аргумента

## 1.7 Использование Map с массивами

_Задание._
За Кленовой горой парням и девушкам из команды развития нужно помочь в решении проблемы. Они получили несколько именных данных от терминала клиента, которые они хотели бы использовать для настройки приветствия для каждого из своих пассажиров, но, увы, массив оказался состоящим из множества подмассивов, в готорых имя и фамилия каждого пассажира разделены. Это делает его "огромной" преградой для изменения всего существующего кода, который был написан для поиска только одной строки в одну ячейку массива, как они надеялись. Они должны действительно знать, чтобы проверить, какого рода данные они получают первыми, не так ли? Хех. Эти ребята.     
Во всяком случае, чтобы исправить свою ошибку, они попросили написать им функцию, которая объединит имена и фамилии каждого пассажира в одну строку, а затем установить (map) эту функцию во все данные массива. Кроме того, они хотели бы функциональное выражение построить только в качестве аргумента функции map. ("Без обмана с переменными!" - Команда разработчиков).    
В качестве примера, если Джейсон ехал на американских горках (и если ехал не он), нужно изменить ячейку с `["Jason", "Millhouse"]` на `"Jason Millhouse"`. Важно заметить, что в функцию  входит массив, но выходит строка.     
Существующий массив представлен ниже. Также важно не забыть сохранить массив новых данных и имя в переменной modifiedNames.
```javascript
var passengers = [["Thomas", "Meeks"], 
                  ["Gregg", "Pollack"], 
                  ["Christine", "Wong"], 
                  ["Dan", "McGaw"]];
```

_Решение._
Ниже готового кода создаём переменную modifiedNames, которой присваиваем переменную passengers с методом map(), где и строим нашу анонимную функцию с аргументом arrayCell и возвращаем этот аргумент после некоторой корректировки:
```javascript
var modifiedNames = passengers.map(function (arrayCell) {
    return arrayCell [0] + " " + [1];
});
```

_Пояснение._
Функциональные выражения просто... выражения. Мы можем передавать их без переменных! Метод map() всегда будет принимать функции в качестве параметра, и возвращать новый массив с полученными результатами. Map() работает как цикл, который применяет функцию к каждому индексу массива. Map() массива удобно заменяет весь формат цикла и объединяет его в одной линии кода. 

## 1.8 Использование Map с массивами II

_Задание._
Пассажиры прибыли в Кленовые горы! Пользуясь массивом modifiedNames и map новой функции, сделать так, чтобы функция отправляла только следующее сообщение на экран для каждого пассажира: 
```javascript
"Yo, <name>!"
```
Так как ранее не возвращалось ничего особенного или изменялись любые данные, не нужно будет хранить любой полученный массив. Массив modifiedNames предоставляется для справки.

_Решение._
Используя решение предыдущего задания, выведем необходимое сообщение на экран:
```javascript
modifiedNames.map(function (arrayCell) {
    return arrayCell [0] + " " + [1];
});
alert("Yo, " + modifiedNames + "!");
```

_Пояснение._
Функцию в map() можно писать, как и в остальных случаях, в несколько строк, но для ясности и простоты часто короткие функции пишутся в одну линию.

## 1.9 Выражения внутри массивов

_Задание._
Людям в Poplar Puzzlers нужен массив функций для одной из своих головоломок. Они попросили помощи в сборке массива, который они хотели бы назвать Puzzlers. Каждый элемент массива должен содержать функцию, эти функции перечислены здесь в порядке: 
  1. Возвращает 3 раза ввод минус 8. 
  2. Возвращает куб суммы ввода и 2. 
  3. Возвращает 9 вычесть квадрат результата ввода. 
  4. Возвращает остаток после деления ввода на 4.    
Используя знания массивов и анонимных функциональных выражений, построить этот набор функций.

_Решение._
Переменной puzzlers присваиваем массив с необходимыми функциями:
```javascript
var puzzlers = [
    function (input) {
        return (3 * input) - 8;
    },
    function (input) {
        return (input + 2) * (input + 2) * (input + 2);
    },
    function (input) {
        return 9 - (input * input);
    },
    function (input) {
        return input % 4;
    }];
```

_Пояснение._
Мы можем сразу поместить в массив функции, а можем построить их за пределами массива, передав, затем, только имена.

# 1.10 Раздел 3 - Возврат функций и их вызов напрямую

## 1.11 Выбор своего собственного приключения

_Задание._
Приключение Ash имеет три различных "приключения" на выбор. Во-первых, клиенту будет выведена на экран подсказка (prompted) с номером терминала, которая передается в функции под названием adventureSelector. Эта функция должна создавать ограждение сообщения функции, основанной на номере, полученном пользователем, а затем возвращает эту функцию, хранимую в переменной так, что она может быть использована позже.    
Разработчики Ash Приключений попросили построить эту функцию, и возвращать только функциональные выражения без дополнительных переменных. Различные сообщения, которые должны быть выведенны (alert) в функциях:
  * Если пользователь выбирает 1:
```
"You've selected the Vines of Doom!
Hope you have a swingin' time."
```
  * Если пользователь выбирает 2:
```
"Looks like you want the Lake of Despair!
Watch out for crocs. And I ain't talkin' about shoes."
```
  * Если пользователь выбирает 3 :
```
"The Caves of Catastrophe, really?
Alright, well....nice knowing you."
```
Предположим, выбор пользователя уже был сохранён как 1, 2, или 3 (и только они), и передаётся в качестве параметра userChoice. Нужно убедиться, что возвращаются все сообщения функций как выражения, вместо хранения в переменных.

_Решение._
В тело функции adventureSelector помещаем 3 условия, при выполнении которых будет возвращаться анонимная функция с подходящим сообщением:
```javascript
function adventureSelector(userChoice) {
    if (userChoice == 1) {
        return function () {
            alert("You've selected the Vines of Doom\n" +
                "Hope you have a swingin' time.");
        };
    } else if (userChoice == 2) {
        return function () {
            alert("Looks like you want the Lake of Despair!\n" +
                "Watch out for crocs. And I ain't talkin' about shoes.");
        };
    } else return function () {
        alert("The Caves of Catastrophe, really?\n" +
            "Alright, well....nice knowing you.")
    };
}
```

_Пояснение._
Так как функции можно рассматривать как выражения, они также могут быть возвращены в качестве значений. Если функция рассматривается как выражение и возвращается непосредственно она, то не нужно создавать дополнительный контейнер для хранения переменной. 

## 1.12 Напрямую запускаемое Приключение

_Задание._
Написать одну строку кода, вызывающего adventureSelector, когда пользователь выбирает 3, которая автоматически вызывает необходимую.

_Решение._
Вызовем функцию:
```javascript
adventureSelector(3)();
```

_Пояснение._
Чтобы вызвать функцию, содержащуюся в переменной, нам нужен набор: круглые скобки и точка с запятой. При необходимости, в скобки передаются аргументы.

## 1.13 Генератор очереди

_Задание._
Теперь ребята из Poplar Puzzlers хотели бы рассматривать массив функций, таких как очереди, передавая результат каждой функции в следующую, пока очередь не опустеет. Они прислали новые функции очереди и "простое указание":
> В переменной с именем applyAndEmpty, построить и сохранить функцию, которая принимает одно число и любую очередь функций в качестве входных данных, а затем применяет функции из очереди по порядку для введённого числа, где результаты каждой функции становятся следующим аргументом. Кроме того, очередь должна опустошаться в течении выполнения. Наконец, потому что мы просто чертовски потрясающи, каждый цикл должен быть for. MWAHAHA. Затем вызовите новую функцию, используя число 2 и прилагаемый список puzzlers в качестве аргумента, и выведите результат на экран (alert).
> PuZzLe MaSTeRs   
Новая функция очереди используется ниже:
```javascript
var puzzlers = [
    function (a) {return 8 * a - 10;},
    function (a) {return (a - 3) * (a - 3) * (a - 3);},
    function (a) {return a * a + 4;},
    function (a) {return a % 5;}
];
```

_Решение._
Так как длина постоянно меняется, создадим перед циклом переменную length, которая принимает значение новой длины массива. Далее строим цикл, который будет продолжаться всю длину массива и сообщаем в нём, что введённое число будет принимать полученное ранее значение, удаляя предыдущую функцию:
```javascript
var puzzlers = [
    function (a) {return 8 * a - 10;},
    function (a) {return (a - 3) * (a - 3) * (a - 3);},
    function (a) {return a * a + 4;},
    function (a) {return a % 5;}
];

var start = 2;

var applyAndEmpty = function (input, queue) {
    var length = queue.length;
    for (var i = 0; i < length; i++) {
        input = queue.shift()(input);
    }
    return input;
};

alert(applyAndEmpty(start, puzzlers));
```

_Пояснение._
Метод shift() удаляет и одновременно возвращает первое значение массива. Как pop() и push(), shift() будет автоматически изменять длину массива. Метод shift() всегда возвращает первую ячейку, используется ли он в выражении, хранится в переменной, или даже не используется вообще.

## 1.14 Напрямую запускаемый Puzzler

_Задание._
Создатели the Poplar Puzzle не были впечатлены. Они едва заметили наш ​​простой и красивый массив функций и восприняли без интузиазма массив в качестве очереди. Но сейчас, они послали головоломку, нужно использовать новый набор функций с этой головоломкой. Так, для отображения нашего впечатляющего массива и мастерства использования функциональных выражений, нужно вывести ответ на следующий вопрос:    
"Что получается, когда результат передачи 9 в функцию 4, затем передаётся в функцию, индекс массива которой соответствует результату передачи 3 в функцию 2?"
```javascript
var puzzlers = [
  function (a) {return 8 * a - 10;}, 
  function (a) {return (a - 3) * (a - 3) * (a - 3);}, 
  function (a) {return a * a + 4;},
  function (a) {return a % 5;}
];
```
Для того чтобы действительно произвести впечатление на создателей головоломки, выводимое сообщение должно:
  1. Не содержать описание вычисления или жёсткий математический код в нашей части  
  2. Использовать индексы массивов для доступа к функциям  
  3. Использовать круглые скобки для передачи аргументов в напрямую запускаемых функциях  
  4. Использовать только одну линию кода

_Решение._
```javascript
alert(puzzlers[puzzlers[1](3)](puzzlers[3](9)));
```
