# 5.1 Прототипы

## 5.2 Прототипы I

_Задание._
Ковбои-разработчики из the Plains of Prototypes обратились за помощью. У них есть большой соединитель стада для управления и несколько списков скота, импортируемого из нескольких регионов. Каждое отдельное жвачное животное представлено ​​в виде объекта JavaScript, а разнообразные представители крупного рогатого скота объединены в виде неупорядоченного списка в массив. Вот пример, который является списком, доставленным из старого доброго Conditional Canyon:
```javascript
var canyonCows = [
  {name: "Bessie", type: "cow", hadCalf: "Burt"},
  {name: "Donald", type: "bull", hadCalf: null},
  {name: "Esther", type: "calf", hadCalf: null},
  {name: "Burt", type: "calf", hadCalf: null},
  {name: "Sarah", type: "cow", hadCalf: "Esther"},
  {name: "Samson", type: "bull", hadCalf: null},
  {name: "Delilah", type: "cow", hadCalf: null}
];
```
Единственная проблема заключается в том, что ковбои-разработчики не имеют времени, чтобы пройти через десятки полученных списков и рассчитать каждый конкретный тип импортируемого крупного рогатого скота, то есть количество коров, быков, или телят. Поскольку список объектов скота в виде массива, они попросили пройти вперед и добавить функцию, которая называется countCattle, в массив прототипа, что учтёт любой список массива крупного рогатого скота, чтобы получить доступ к количеству быков, коров и телят, присутствующих в массиве. Функция должна принимать параметр и возвращать числовое значение.

_Решение._
У встроенного объекта-прототипа определим свойство countCattle и присвоим ему функцию с аргументом cattle (при вызове заменим его названием конкретного животного). В теле функции создаём переменную number со стартовым значением 0, которую и будет возвращать функция в качестве результата подсчёта количества cattle. Далее строим цикл, который будет проходить по всем элементам массива и, если type элемента будет совпадать с введёным животным, то количество будет увеличиваться:
```javascript
Array.prototype.countCattle = function (cattle) {
    var number = 0;
    for (var i = 0; i < this.length; i++) {
        if (this[i].type == cattle) {
            number++;
        }
    }
    return number;
};
```

_Пояснение._
Объекты, которые мы создавали до сих пор имеют тайные свойства, которые мы никогда не видели (valueOf, constructor, toLocaleString, toString, isPrototypeOf, propertyIsEnumerable, hasOwnProperty)! Родитель объекта называется его "прототипом". Все эти загадочные свойства принадлежат и происходят из прототипов объекта. Когда создается общий объект, его прототип передаёт ему много важных свойств. Прототип, как шаблон объекта для объекта, который мы пытаемся создать.

## 5.3 Прототипы II

_Задание._
Ковбои-разработчики определились, что им нужны телята из каньона, быки из долины и коровы из леса вместе, в одном пастбище на равнинах. Им нужно знать, какие пастбища использовать и решить это на основе того, сколько скота эти три группы представляют. Используя функцию, добавленную к прототипу, построить одну строку кода, которая выводит сумму: 
  1. Телят в массиве canyonCows. 
  2. Быков в массиве valleyCows. 
  3. Коров в массива forestCows.  
Списки предоставляются для ознакомления... хотя, вероятно, они не нужны для правильного создания кода.
```javascript
var canyonCows = [
  {name: "Bessie", type: "cow", hadCalf: "Burt"},
  {name: "Donald", type: "bull", hadCalf: null},
  {name: "Esther", type: "calf", hadCalf: null},
  {name: "Burt", type: "calf", hadCalf: null},
  {name: "Sarah", type: "cow", hadCalf: "Esther"},
  {name: "Samson", type: "bull", hadCalf: null},
  {name: "Delilah", type: "cow", hadCalf: null}
];
```
```javascript
var valleyCows = [
  {name: "Danielle", type: "cow", hadCalf: null},
  {name: "Brittany", type: "cow", hadCalf: "Christina"},
  {name: "Jordan", type: "bull", hadCalf: null},
  {name: "Trevor", type: "bull", hadCalf: null},
  {name: "Christina", type: "calf", hadCalf: null},
  {name: "Lucas", type: "bull", hadCalf: null}
];
```
```javascript
var forestCows = [
  {name: "Legolas", type: "calf", hadCalf: null},
  {name: "Gimli", type: "bull", hadCalf: null},
  {name: "Arwen", type: "cow", hadCalf: null},
  {name: "Galadriel", type: "cow", hadCalf: null},
  {name: "Eowyn", type: "cow", hadCalf: "Legolas"}
];
```

_Решение._
Выводим сумму требуемого животных из массивов, используя созданый ранее прототип:
```javascript
alert(canyonCows.countCattle("calf") +
    valleyCows.countCattle("bull") +
    forestCows.countCattle("cow"));
```

_Пояснение._
Передача свойств называется "наследованием". Наследование позволяет избежать чрезмерного кодирования нескольких свойств и методов в подобных объектах. Все прототипы наследуются от объекта прототипа и доступны через свойство prototype. Наследование позволяет избежать дублирования памяти хранения. Хотя свойства наследуются, они по-прежнему "принадлежат" прототипам, а не наследуемым объектам.

## 5.4 Прототипы III

_Задание._
Чтобы дать матерям коров отдохнуть, ковбои-разработчики из the Plains of Prototypes решили разводить только тех коров, которые ещё не рожали телят. Поскольку ковбои-разработчики используют только встроенные в JavaScript объекты, в их представлении крупного рогатого скота (это грубая жизнь), они хотят пойти дальше и добавить некоторую функциональность на сам объект прототипа. Они попросили построить две функции в описаном здесь порядке:
  1. Функция называется noCalvesYet, которая будет добавлена в прототип Object и возвращать true для объекта, если он содержит корову без телят... и false в противном случае.
  2. Функция называется countForBreeding, которая будет добавлена в прототип Array и просматривать список массива в объектах крупного рогатого скота, считая всех коров, которые не мамы. Чтобы сделать это, нужно использовать функцию в критерии числа (1), а также использовать переменную-счетчик под названием numToBreed. В конце концов, эта функция должна вернуть numToBreed представляющую сколько именно коров-нематерей доступно в любом массиве.  
Список скота приводится ниже для справки:
```javascript
var forestCows = [
  {name: "Legolas", type: "calf", hadCalf: null},
  {name: "Gimli", type: "bull", hadCalf: null},
  {name: "Arwen", type: "cow", hadCalf: null},
  {name: "Galadriel", type: "cow", hadCalf: null},
  {name: "Eowyn", type: "cow", hadCalf: "Legolas"}
];
```

_Решение._
Начинаем с первой функции, работающей с каждым объектом. Создаём условие, при котором, если корова рожала, будет возвращаться истина (WS любезно предложил мне короткий вариант записи, за что ему огромное спасибо). Далее переходим к массиву: проходим по каждому его элементу и, если он соответствует условиям предыдущей функции, прибавляем 1 к numToBreed:
```javascript
Object.prototype.noCalvesYet = function () {
    return this.hadCalf == null && this.type == "cow";
};

Array.prototype.countForBreeding = function () {
    var numToBreed = 0;
    for (var i = 0; i < this.length; i++) {
        if (this[i].noCalvesYet()) {
            numToBreed++;
        }
    }
    return numToBreed;
};
```

_Пояснение._
При изменении прототипа Object прототип Array также изменится, так как прототип массива наследует прототип объекта.

## 5.5 Прототипы IV

_Задание._
Итак, пора выяснить, какие коровы в очереди для первого размножения. Мои удивительные навыки в прототипировании делают жизнь ковбоев-разработчиков проще на столько, что они попросили использовать новые функции, чтобы узнать, у скольких коров из списков, которые находятся ниже, не было телят. Рассчитать эту сумму и сохранить её в переменной, названной numPriorityCows. Вывести следующее сообщение на экран:
```
Herd-merger has indicated <number> cows of top breeding priority.
```
```javascript
var canyonCows = [
  {name: "Bessie", type: "cow", hadCalf: "Burt"},
  {name: "Donald", type: "bull", hadCalf: null},
  {name: "Esther", type: "calf", hadCalf: null},
  {name: "Burt", type: "calf", hadCalf: null},
  {name: "Sarah", type: "cow", hadCalf: "Esther"},
  {name: "Samson", type: "bull", hadCalf: null},
  {name: "Delilah", type: "cow", hadCalf: null}
];

var valleyCows = [
  {name: "Danielle", type: "cow", hadCalf: null},
  {name: "Brittany", type: "cow", hadCalf: "Christina"},
  {name: "Jordan", type: "bull", hadCalf: null},
  {name: "Trevor", type: "bull", hadCalf: null},
  {name: "Christina", type: "calf", hadCalf: null},
  {name: "Lucas", type: "bull", hadCalf: null}
];

var forestCows = [
  {name: "Legolas", type: "calf", hadCalf: null},
  {name: "Gimli", type: "bull", hadCalf: null},
  {name: "Arwen", type: "cow", hadCalf: null},
  {name: "Galadriel", type: "cow", hadCalf: null},
  {name: "Eowyn", type: "cow", hadCalf: "Legolas"}
];

var badlandsCows = [
  {name: "Voldemort", type: "bull", hadCalf: null},
  {name: "Maleficent", type: "cow", hadCalf: null},
  {name: "Ursula", type: "cow", hadCalf: "Draco"},
  {name: "Draco", type: "calf", hadCalf: null},
  {name: "Joker", type: "bull", hadCalf: null},
  {name: "Chucky", type: "calf", hadCalf: null},
  {name: "Samara", type: "cow", hadCalf: "Chucky"}
];
```

_Решение._
Для начала, в переменной numPriorityCows находим сумму всех не рожавших коров, а затем выводим полученное число в предупреждающем окне с требуемым сообщением:
```javascript
var numPriorityCows = canyonCows.countForBreeding() +
    valleyCows.countForBreeding() +
    forestCows.countForBreeding() +
    badlandsCows.countForBreeding();

alert("Herd-merger has indicated " +
    numPriorityCows +
    " cows of top breeding priority.");
```

_Пояснение._
До сих пор, все литералы объекта мы делали с {}, наследуя непосредственно на самом высоком уровне в иерархии JS прототип объекта... Оказывается, все встроенные структуры данных JS наследуют все их свойства и методы от своих собственных прототипов!

# 5.6 Наследование и Конструкторы

## 5.7 Создание с прототипами I

_Задание._
У ковбоев-разработчиков из the Plains of Prototypes есть новая проблема, которой они действительно взволнованы. Впервые у них появилась новая роботизированная столбовая система изгородей для пастбищ. Эта система является довольно классной, потому что она позволяет мгновенно перемещать столбы на колесной основе, принуждая мигрировать коров в различные, полезные пастбища для выпаса.   
Вот общий объект забора, начиная с координат (0,0), которые являются расположением главного ранчо:
```javascript
var genericPost =
{x: 0, y: 0, postNum: undefined,
    connectionsTo: undefined,
    sendRopeTo: function (connectedPost) {
        if (this.connectionsTo == undefined) {
            var postArray = [ ];
            postArray.push(connectedPost);
            this.connectionsTo = postArray;
        } else {
            this.connectionsTo.push(connectedPost);
        }
    }
};
```
Каждый новый столб забора будет перемещаться, сам по себе, к координатам присвоенным ему при создании нового сгенерированного для него объекта. Там он будет отсылать робота, направившего объединяющие канаты к другим, соответствующим объявлению столбам для ограждения пастбища. Нужно иметь в виду, что он берёт два каната для объединения столбов забора; т.е. каждый посылает канат к другому. Внимательно изучить прототип, чтобы видеть, как продумана система.
Чтобы проверить соответствие объектов этих новых столбов забора, ковбои-разработчики выдвинули несколько требований: 
  1. Использовать метод Object.create и базовый столб забора в качестве прототипа для создания двух новых столбов: post1 и post2.
  2. Отправить первый столб забора в (-2, 4), используя стандартную модификацию свойства только с точками. Также установить его номер на 1.
  3. Отправить второй столб забора в (5, 1) с использованием стандартной модификации свойства только с точками. Также установить его номер на 2.
  4. Использовать метод, унаследованный от прототипа для объединения столбов забора вместе. Каждый массив connectionsTo должен принимать весь объект.   
Построить несколько столбов.

_Решение._
Создаём два новых столба, используя метод Object.create и базовый столб. Затем задаём новые значения некоторым свойствам и объединяем столбы вместе с помощью прототипа sendRopeTo:
```javascript
var post1 = Object.create(genericPost);
var post2 = Object.create(genericPost);

post1.x = -2;
post1.y = 4;
post1.postNum = 1;
genericPost.sendRopeTo(post1);

post2.x = 5;
post2.y = 1;
post2.postNum = 2;
genericPost.sendRopeTo(post2);
```

_Пояснение._
Второй способ построить объекты - с помощью Object.create(). Используя наследование, мы можем создать новые Объекты с уже существующими Объектами, как прототипы. Для этого создаём переменную с именем нового объекта и присваиваем ей Object.create(), где первый аргумент будет использоваться в качестве прототипа для вновь созданного объекта. Новый объект унаследует все свойства от старого, так же, как мы ожидали бы от прототипа. Чтобы добавить новые свойства созданному объекту или изменить старые, пользуемся уже знакомыми нотациями (. или [""]). Старый объект при этом останется не изменным.

## 5.8 Создание с прототипами II

_Задание._
Оказывается, что есть несколько столбов, которые имеют некоторые специальные свойства. Некоторые из них имеют флюгера, некоторые скворечники, а некоторые даже мигалки. 
Ниже приведены данные для трех столбов, которые должны быть созданы с помощью genericPost в качестве прототипа (как и в прошлой задаче). Ковбои передали все данные, каждое из которых нужно будет построить с использованием прототипа, а затем присвоить уникальные значения свойств за счет модификации. Назвать каждый из столбов post<number>, как это было в последней задаче.
  1. x: 0, y: -3,
     postNum: 8,
     connectionsTo: 10
  2. x: 6, y: 8,
     postNum: 9,
     connectionsTo: 10
  3. x: -2, y: 3,
     postNum: 10,
     connectionsTo: 8, 9  
Ковбои-разработчики подготовили список добавлений, которые должны произойти для некоторых специальных столбов. После того как будут построены верхние три сообщения, добавить свойства к тем столбам, которые ковбой-разработчики сочли подходящими. 
  1. Любые столбы с чётным координатом "у" имеют скворечник, и поэтому их свойство numBirds первоначально установлено в 0. 
  2. Любые столбы, связанные со столбом #9, кроме него самого, имеют свойство weathervane первоначально установленое в "N". 
  3. Столбы с чётными номерами имеют мигалки, и их свойство lightsOn первоначально установлено как false.   
Базовый fencepost размещен для ознакомления. 

_Решение._
В этот раз с помощью метода Object.create создаём три столба, каждому из них присваиваем требуемые данные, а затем, с помощью не хитрых подсчётов добавляем новые свойства:
```javascript
var genericPost = {
    x: 0,
    y: 0,
    postNum: undefined,
    connectionsTo: undefined,
    sendRopeTo: function (connectedPost) {
        if (this.connectionsTo == undefined) {
            var postArray = [ ];
            postArray.push(connectedPost);
            this.connectionsTo = postArray;
        } else {
            this.connectionsTo.push(connectedPost);
        }
    }
};
var post8 = Object.create(genericPost);
var post9 = Object.create(genericPost);
var post10 = Object.create(genericPost);

post8.x = 0;
post8.y = -3;
post8.postNum = 8;
genericPost.sendRopeTo(post10);
post8.lightsOn = false;

post9.x = 6;
post9.y = 8;
post9.postNum = 9;
genericPost.sendRopeTo(post10);
post9.numBirds = 0;

post10.x = -2;
post10.y = 3;
post10.postNum = 10;
genericPost.sendRopeTo(post8, post9);
post10.weathervane = "N";
post10.lightsOn = false;
```

_Пояснение._
Добавить новые свойства можно таким же способом, как и изменить старые ([см. 5.7](https://github.com/Preigile/CodeschoolHints/blob/master/JavaScript/JavaScript_Road_Trip_Part_3/5.the_plains_of_prototypes.md#57-%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D1%81-%D0%BF%D1%80%D0%BE%D1%82%D0%BE%D1%82%D0%B8%D0%BF%D0%B0%D0%BC%D0%B8-i)).

## 5.9 Конструктор I

_Задание._
Итак, теперь ковбои-разработчики настолько озабочены своими роботизированными столбами, что решили пойти дальше и сделать конструктор функции для столбов, которой они могут передать несколько параметров и вернуть новый экземпляр столба. 
Задача состоит в том, чтобы взять существующий genericPost и восстановить все его свойства внутри одного конструктора Fencepost (наследование будет в следующем задании). genericPost предоставляется ниже:
```javascript
var genericPost =
{x: 0, y: 0, postNum: undefined,
    connectionsTo: undefined,
    sendRopeTo: function (connectedPost) {
        if (this.connectionsTo == undefined) {
            var postArray = [ ];
            postArray.push(connectedPost);
            this.connectionsTo = postArray;
        } else {
            this.connectionsTo.push(connectedPost);
        }
    }
};
```
Конструктор должен принять в качестве аргументов имена, которые были именами свойств в genericPost, за одним исключением. Ковбои-разработчики попросили назначить свойству connectionsTo изначально быть пустым массивом внутри конструктора (аргумент не требуется). Затем изменить функцию sendRopeTo таким образом, чтобы она ожидала существующий массив, вместо того, чтобы создавать его, как сейчас, когда она видит значение undefined. Это, кстати, сделает функцию значительно меньше. 
Нужно помнить, что на данный момент также нужно строить любые функции, как свойства, непосредственно в конструкторе.

_Решение._
Создаём конструктор функции Fencepost с тремя аргументами. Сообщаем, что каждый из этих аргументов присвоен одноимённой функции. Свойству же connectionsTo присваиваем пустой массив, а в функции сообщаем, что в качестве аргумента она должна ожидать существующий массив:
```javascript
function Fencepost(x, y, postNum) {
    this.x = x;
    this.y = y;
    this.postNum = postNum;
    this.connectionsTo = [];
    this.sendRopeTo = function (connectedPost) {
        this.connectionsTo.push(connectedPost);
    };
}
```

_Пояснение._
Бывает, что видов объектов достаточно много. Можно построить прототип с пустыми свойствами. Из общего объекта можно было бы построить все остальные, и назначить значения свойств позже. Но такой вариант очень не удобный, так как прийдётся назначать каждому свойству объекта своё значение, что сделает код очень громоздким и потребует много времени на его написание.  
Есть другой способ. Во-первых, мы определяем общие свойства класса главного объекта. Класс представляет собой набор объектов, которые всё разделяют и наследуют от того же базового прототипа. Данный способ строится с помощью функции-конструктора. Конструктор позволяет настроить наследуемые а также присвоенные конкретные значения свойств. Начало имени этой функции с заглавной буквы отличает его как производителя целого "класса" объектов... конструктор. Каждый из аргументов функции будет принимать конкретное значение для определенного вида нового объекта. Функция конструктора будет "строить" новую "копию" объекта и назначить эти значения для него. Ключевое слово this в конструкторе автоматически относится к новым экземпляром класса, которые в настоящее время сделаны.
```javascript
function ИмяКонструктораФункции(свойство1, свойство2, ещёНесколькоСвойств) {
    this.свойство1 = свойство1;
    this.свойство2 = свойство2;
    this.ещёНесколькоСвойств = ещёНесколькоСвойств;
}
```

## 5.10 Конструктор II

_Задание._
Теперь, когда конструктор Fencepost готов, нужно создать несколько столбов! 
Ковбоям-разработчикам нужны три новых столба для равнины, описанных ниже:
  1. x: -3, y: 4
     numPost: 18
  2. x: 5, y: -1,
     numPost: 19
  3. x: -2, y: 10
     numPost: 20.
Используя конструктор, создать эти столбы, называя их post<number>, как раньше. Затем объединить их с помощью объединяющей функции, используя следующие критерии: 
  1. Если два столба имеют чётные у-координаты, то они должны быть объединены. 
  2. Если два столба имеют нечётные координаты х, они должны быть связаны между собой. 
Конструктор предоставляется.

_Решение._
С помощью функции Fencepost создаём новые объекты с требуемыми значениями свойств, а затем объединяем столбы друг с другом (в обоих направлениях):
```javascript
function Fencepost(x, y, postNum) {
    this.x = x;
    this.y = y;
    this.postNum = postNum;
    this.connectionsTo = [];
    this.sendRopeTo = function (connectedPost) {
        this.connectionsTo.push(connectedPost);
    };
}

var post18 = new Fencepost(-3, 4, 18);
var post19 = new Fencepost(5, -1, 19);
var post20 = new Fencepost(-2, 10, 20);

post18.sendRopeTo(post20);
post20.sendRopeTo(post18);
post18.sendRopeTo(post19);
post19.sendRopeTo(post18);
```

_Пояснение._
Чтобы использовать созданный конструктор, в JavaScript существует ключевое слово "new", которое создаёт новый объект или "экземпляр" класса `var имяНовогоОбъекта = new ИмяКонструктораФункции("значение свойства1", "значение свойства2", "значение ещёНесколькихСвойств");`. У некоторых объектов могут быть свои конкретные свойства, они создаются как и любое новое свойство объекта `имяОбъекта.новоеСвойство = значение`. К функции-прототипу из тела функции-конструктора имеет доступ любой объект.

## 5.11 Конструктор III

_Задание._
Итак, теперь есть одиннадцать миллиардов столбов повсюду, ковбои-разработчики заметили значительное потребление своих ресурсов памяти. Они попросили осмотреть конструктор Fencepost и проверить, есть ли что-нибудь, что можно добавить в прототип, так чтобы каждый столб не дублировал функционал, который можно держать в одном месте.   
Ниже приводится текущее состояние конструктора, с некоторыми дополнениями, сделаными ковбоями-разработчиками, чтобы улучшить функциональность столбов. Задача заключается в определении части конструктора, которая должна быть общей для всех fenceposts, и помещении её в прототип. Ответ должен включать в себя модифицированный конструктор, а также новую структуру прототипа этого конструктора.
```javascript
function Fencepost(x, y, postNum) {
    this.x = x;
    this.y = y;
    this.postNum = postNum;
    this.connectionsTo = [];
    this.sendRopeTo = function (connectedPost) {
        this.connectionsTo.push(connectedPost);
    };
    this.removeRope = function (removeTo) {
        var temp = [];
        for (var i = 0; i < this.connectionsTo.length; i++) {
            if (this.connectionsTo[i].postNum != removeTo) {
                temp.push(this.connectionsTo[i]);
            }
        }
        this.connectionsTo = temp;
    }
    this.movePost = function (x, y) {
        this.x = x;
        this.y = y;
    };
}
```

_Решение._
Переменные оставляем в конструкторе, а функции переносим в прототип в качестве значения свойств:
```javascript
function Fencepost(x, y, postNum) {
    this.x = x;
    this.y = y;
    this.postNum = postNum;
    this.connectionsTo = [];
}

Fencepost.prototype = {
    sendRopeTo: function (connectedPost) {
        this.connectionsTo.push(connectedPost);
    },
    removeRope: function (removeTo) {
        var temp = [];
        for (var i = 0; i < this.connectionsTo.length; i++) {
            if (this.connectionsTo[i].postNum != removeTo) {
                temp.push(this.connectionsTo[i]);
            }
        }
        this.connectionsTo = temp;
    },
    movePost: function (x, y) {
        this.x = x;
        this.y = y;
    }
};
```

_Пояснение._
Если что-то внутри конструктора остаётся не изменным для каждого нового объекта, то это что-то можно поместить в прототип, так чтобы оно хранилось эффективно только в одном месте, и чтобы все объекты могли получить доступ к нему. Установив свойство прототипа конструктора, каждый новый экземпляр будет ссылаться на его дополнительные свойства! 

# 5.12 Переопределение методов прототипов

## 5.13 Переопределение прототипных методов I

_Задание._
Ковбоям-разработчикам не везёт со встроенным в прототип Object свойством valueOf(). В настоящее время они получают длинный список свойств, но то, что они действительно хотели бы знать, как далеко столб от ранчо (0,0) по прямой.   
Задача заключается в переопределении функции valueOf(), используя прототип Fencepost, чтобы получить точное расстояние от столба до ранчо.   
Вот стандартная алгебраическая формула для определения расстояния:  
расстояние = корень из [(x1 - x2) ^ 2 + (y1 - y2) ^ 2].  
Эта формула включает в себя точки (x1, y1) для столба и (x2, y2) для ранчо.   
Примечание: Так как координаты ранчо всегда (0,0), нужно быть в состоянии значительно сократить эту процедуру, или, в самом крайнем случае, захардкодить некоторые значения. Но нужно внимательно подумать о том, как нулевые координаты ранчо могут облегчить эту формулу. Одну, без вычитания всего...   
Для того, чтобы можно было выполнить это в коде, ковбои-разработчики отправили дополнительные инструменты, которых не было в видео...  Метод sqrt() класса Math!
```
Math.sqrt(49);      // 7
Math.sqrt(45+55);   // 10
Math.sqrt(30/6);    // 2.23606797749979
Math.sqrt("YOLO")   // Не делай глупостей.
```
Можно разместить любое числовое выражение, которое понравится, в качестве параметра для метода Math.sqrt(), и он будет извлекать квадратный корень после вычисления выражения. Нужно использовать этот метод осторожно, и не стесняться проверить его на своей ​​консоли, если нужно. 

_Решение._
Переопределяем метод valueOf() так, чтобы он выводил не всё содержимое объекта, а выражение, определяющее расстояние по прямой:
```javascript
Fencepost.prototype.valueOf = function () {
    return Math.sqrt(this.x * this.x + this.y * this.y);
};
```

_Пояснение._
Метод valueOf() преобразовывает объект в представляющее его простое значение, если такое значение существует. Любой существующий метод в JS можно переопределить. Для этого свойству метода мы присваиваем новую анонимную функцию, которая и будет заменять предыдущую. Для методов, определённых в Object, справедлива перезапись методов в теле нового прототипа. 

## 5.14 Переопределение прототипных методов II

_Задание._
Следующим шагом ковбои-разработчики из the Plains of Prototypes попросили усовершенствовать метод toString для их столбов. Пример строки сообщения, которое они хотели видеть - ниже:
```
Fence post #10:
Connected to posts:
11
12
13
Distance from ranch: 5 yards
```
Переопределить метод toString с помощью прототипа Fencepost и недавно построенной функции, которая возвращает строковое сообщение в таком формате, но с уникальными данными для каждого столба. Конструктор и все предыдущие дополнения прототипов предоставляются в качестве эталона для имен и процедур свойств. Важно помнить, что connectionsTo - это список объектов Fencepost.

_Решение._
Переопределяем метод toString; в теле функции создаём пустую текстовую переменную list. Далее строим цикл, где каждый элемент массива connectionsTo помещаем в список, а следующий переносим на новую строку. В конце концов возвращаем требуемый текст со свойством postNum в качестве номера столба,  переменной list в качестве связанных столбов и новосозданным методом valueOf() в качестве расстояния:
```javascript
function Fencepost(x, y, postNum) {
    this.x = x;
    this.y = y;
    this.postNum = postNum;
    this.connectionsTo = [];
}
Fencepost.prototype = {
    sendRopeTo: function (connectedPost) {
        this.connectionsTo.push(connectedPost);
    },
    removeRope: function (removeTo) {
        var temp = [];
        for (var i = 0; i < this.connectionsTo.length; i++) {
            if (this.connectionsTo[i].postNum != removeTo) {
                temp.push(this.connectionsTo[i]);
            }
        }
        this.connectionsTo = temp;
    },
    movePost: function (x, y) {
        this.x = x;
        this.y = y;
    },
    valueOf: function () {
        return Math.sqrt(this.x * this.x + this.y * this.y);
    }
};

Fencepost.prototype.toString = function () {
    var list = "";
    for (var i = 0; i < this.connectionsTo.length; i++) {
        list = list + this.connectionsTo + "\n";
    }
    return "Fence post #" + this.postNum + ":\n" +
        "Connected to posts:\n" + list +
        "Distance from ranch: " + this.valueOf() + " yards";
};
```

_Пояснение._
Метод toString явно вызывается, когда требуется строка. Переопределение этого метода позволяет представить объект в понятном строковом виде. 