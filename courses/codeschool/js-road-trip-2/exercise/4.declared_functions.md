# 4.1 Введение в финкции

## 4.2 Базовая функция умножения

_Задание._
В uniqueMath.js построить объявление функции multiplyTrio, которая принимает 3 аргумента. Нужно умножить эти числа друг с другом и вернуть (return) полученный результат. Можно использовать любые имена переменных и аргументов.

_Решение._
Пусть функция multiplyTrio принимает в качесиве аргументов числа: первое, второе и третье. Так их и назовём: num1, num2, num3. а возвращать функция будет произведение этих чисел:
```javascript
function multiplyTrio(num1, num2, num3) {
    return num1 * num2 * num3;
}
```

_Пояснение._
Функция преобразовывает введённые данные и возвращает полученный результат. Обозначается функция ключевым словом function, за которым следует её имя. Лучше всего в качестве имени использовать краткое описание происходящего. В круглые скобки принимаются аргументы, которые являются "материалами", над которыми будет проводиться работа; их может быть любое количество. Кстати, иногда функции не нужны никакие параметры! "Процесс" функции заключается в фигурные скобки. Результат возвращается ключевым словом return, которое может находиться в любом месте функции, оно как бы говорит: "Хорошо, мы всё сделали, теперь я отдаю результат сделанного.". Структура:
```javascript
function имяФункции(аргументы) {
	код
	return результат;
}
```

## 4.3 Вызываем объявленную функцию

_Задание._
Вызвать функцию multiplyTrio function из консоли, используя числа 8, 4, 10.

_Решение._
Пишем имя функции и конкретизируем аргументы:
```javascript
multiplyTrio(8, 4, 10);
```

_Пояснение._
Вызов функции включает в себя имя функции и некоторые аргументы. Аргументы также могут быть выражениями, которые функция будет решать перед запуском: `sumOfCubes(1+2, 3+5);`.

## 4.4 Больше объявлений

_Задание._
Построить объявление функции maxOf2, которая принимает 2 числа и возвращает значение большего. Нужно обратить внимание на то, что  числа могут быть равны, а выведено должно быть только одно из чисел.

_Решение._
Помещаем в функцию условие:
```javascript
function maxOf2(num1, num2) {
    if (num1 >= num2) {
        return num1;
    } else {
        return num2;
    }
}
```

_Пояснение._
Процессом функции может быть условие. В этом случае в тело каждого условия помещается return.

## 4.5 Рефакторинг для эффективности и читабельности

_Задание._
В uniqueMath.js ниже расположена функция mystery. Отрефакторить код функции так, чтобы она включала в себя только одну линию:
```javascript
function mystery(x, y) {
    var a = 4 * x * y;
    var b = 3 * y + 5;
    var c = a + b;
    return c;
}
```

_Решение._
Переносим все значения в return:
```javascript
function mystery(x, y) {
    return (4 * x * y) + (3 * y + 5);
}
```

_Пояснение._
Краткость помогает экономить память и ограничить операции хранения.

# 4.6 Решение проблем с помощью функций

## 4.7  Решение проблем с помощью функции I

_Задание._
Парковые смотрители в Национальном парке Долины Смерти разделили свои ежедневные обязанности в пользу популяции снежных овец. Они нуждаются в функции feedPerRanger, написанной на сайте рейнджера, которая принимает: (1) текущую популяцию овец И (2) количество смотрителей парка в течение всего дня; а затем выводит (alert) на экран количество корма, за которое каждый смотритель парка должен нести ответственность в этот день. Это позволит смотрителям загружать свои официальные Big-Ass Ranger грузовики (BARTs) соответственно. Каждой овце нужно 2 фунта предоставленной рейнджером пищи в день (в дополнение к редкой растительности, которую она жуёт). Построить объявление функции feedPerRanger. Выходу функции должен соответствовать следующий формат:
```javascript
"Each Park Ranger should load <number> lb(s) of feed into his/her BART today."
```

_Решение._
Переменной number присваиваем вычисление необходимого количества  корма. Далее пишем команду для вывода необходимой строки и не забываем вызвать функцию:
```javascript
function feedPerRanger(currentPopulation, amountRangers) {
    var number = currentPopulation * 2 / amountRangers;
    alert("Each Park Ranger should load " + number +
        " lb(s) of feed into his/her BART today.");
}
feedPerRanger(10, 2);
```

_Пояснение._
Хорошая практика - вызвать функцию несколько раз с разными аргументами. Это поможет протестировать правильность работы функции и обнаружить баги на начальном этапе.

## 4.8 Решение проблем с помощью функции II

_Задание._
Возвращаясь на дамбы Гувера; техникам надоели выключения всех генераторов сразу или ни одного вообще(ANGST). Они решили, что им нужно значительно больше контроля за тем, какие генераторы выключаются. Они попросили разработать способ скорректировать общее количество сгенерированных МВт при включении или отключении одного выбранного генератора. 
Построить объявление функции с именем changePowerTotal, которая принимает: 
  * Общую мощность текущего тока (число) 
  * ID генератора (число) 
  * Новый статус генератора (строка, которая говорит, что "включено" или "выключено") 
  * И величина мощности производимой этим генератором (число)   
Функция должна: 
  * вернуть новую общую генерируемую мощность 
  * предупредить специалиста в следующих форматах 
Для включения:
```
"Generator #2 is now on, adding 62 MW, for a total of 62 MW!"
```
Или для выключения:
```
"Generator #2 is now off, removing 62 MW, for a total of 0 MW!"
```

_Решение._
Во-первых, объявим требуемые аргументы. Во-вторых поместим в функцию условие, при котором мощность увеличивается и выводится одно предупреждение, когда генератор включают или уменьшается мощность и выводится другое предупреждение, когда генератор выключают:
```javascript
function changePowerTotal(totalCurrentPower, genID, genStatus, genPower) {
    if (genStatus == "on") {
        var newTotalPower = totalCurrentPower + genPower;
        alert("Generator #" + genID + " is now "
            + genStatus + ", adding " + genPower +
            " MW, for a total of " + newTotalPower + " MW!");
    } else if (genStatus == "off") {
        var newTotalPower = totalCurrentPower - genPower;
        alert("Generator #" + genID + " is now "
            + genStatus + ", removing " + genPower +
            " MW, for a total of " + newTotalPower + " MW!");
    }
    return newTotalPower;
}
```

_Пояснение._
Когда мы объявляем "глобальную" переменную она становится потенциально доступна отовсюду. Объявленная внутри функции переменная, получает "локальную" область деятельности, как города в пределах государства. Каждый из них имеет своё собственное "правительство" и прочее, что происходит здесь остается здесь. Переменная существует только в локальной области видимости функции, если она была объявлена с var, она не изменяет  переменную с тем же названием «вне» функции. Если переменная внутри функции не была объявлена с var, это "тень" одноименной переменной от ближайшей внешней области действия.
